import logging\"nimport contextlib\"nimport typing\"nimport urllib.parse\"nimport anyio\"nimport httpx\"nfrom anyio.abc import TaskStatus\"nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\"nfrom httpx_sse import aconnect_sse\"nfrom mcp_python.types import JSONRPCMessage\"n\"nlogger = logging.getLogger(__name__)\"n\"n@contextlib.asynccontextmanager\"nasync def sse_client(url: str, headers: typing.Dict[str, typing.Any] | None = None, timeout: float = 5, sse_read_timeout: float = 60 * 5) -> typing.Tuple[MemoryObjectReceiveStream[JSONRPCMessage | Exception], MemoryObjectSendStream[JSONRPCMessage]]:\"n    This function establishes a connection to an SSE endpoint and manages the communication with the server.\"n    read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception] = MemoryObjectReceiveStream()\"n    read_stream_writer: MemoryObjectSendStream[JSONRPCMessage | Exception] = MemoryObjectSendStream()\"n    write_stream: MemoryObjectSendStream[JSONRPCMessage] = MemoryObjectSendStream()\"n    write_stream_reader: MemoryObjectReceiveStream[JSONRPCMessage] = MemoryObjectReceiveStream()\"n    \"n    async with anyio.create_task_group() as tg:\"n        try:\"n            logger.info(f"Connecting to SSE endpoint: {urllib.parse.urlparse(url).path}")\"n            async with httpx.AsyncClient(headers=headers) as client:\"n                async with aconnect_sse(client, "GET", url, timeout=httpx.Timeout(timeout, read=sse_read_timeout)) as event_source:\"n                    event_source.response.raise_for_status()\"n                    logger.debug("SSE connection established")\"n                    \"n                    async def sse_reader(task_status: TaskStatus[str] = anyio.TASK_STATUS_IGNORED):\"n                        This function reads messages from the SSE endpoint.\"n                        try:\"n                            async for sse in event_source.aiter_sse():\"n                                logger.debug(f"Received SSE event: {sse.event}")\"n                                match sse.event:\"n                                    case "endpoint":\"n                                        endpoint_url = urllib.parse.urljoin(url, sse.data)\"n                                        logger.info(f"Received endpoint URL: {endpoint_url}")\"n                                        \"n                                        url_parsed = urllib.parse.urlparse(url)\"n                                        endpoint_parsed = urllib.parse.urlparse(endpoint_url)\"n                                        if url_parsed.netloc != endpoint_parsed.netloc or url_parsed.scheme != endpoint_parsed.scheme:\"n                                            error_msg = f"Endpoint origin does not match connection origin: {endpoint_url}"\"n                                            logger.error(error_msg)\"n                                            raise ValueError(error_msg)\"n                                        task_status.started(endpoint_url)\"n                                    case "message":\"n                                        try:\"n                                            message = JSONRPCMessage.model_validate_json(sse.data)\"n                                            logger.debug(f"Received server message: {message}")\"n                                        except Exception as exc:\"n                                            logger.error(f"Error parsing server message: {exc}")\"n                                            await read_stream_writer.send(exc)\"n                                            continue\"n                                        await read_stream_writer.send(message)\"n                    async def post_writer(endpoint_url: str):\"n                        This function sends messages to the SSE endpoint.\"n                        try:\"n                            async with write_stream_reader:\"n                                async for message in write_stream_reader:\"n                                    logger.debug(f"Sending client message: {message}")\"n                                    response = await client.post(endpoint_url, json=message.model_dump(by_alias=True, exclude_none=True))\"n                                    response.raise_for_status()\"n                                    logger.debug(f"Client message sent successfully: {response.status_code}")\"n                        except Exception as exc:\"n                            logger.error(f"Error in post_writer: {exc}")\"n                        finally:\"n                            await write_stream.aclose()""