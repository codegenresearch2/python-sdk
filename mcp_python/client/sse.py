import logging\nfrom contextlib import asynccontextmanager\nfrom typing import Any\nfrom urllib.parse import urljoin, urlparse\nimport anyio\nimport httpx\nfrom anyio.abc import TaskStatus\nfrom anyio.streams.memory import MemoryObjectReceiveStream, MemoryObjectSendStream\nfrom httpx_sse import aconnect_sse\nfrom mcp_python.types import JSONRPCMessage\n\nlogger = logging.getLogger(__name__)\n\ndef remove_request_params(url: str) -> str:\n    return urljoin(url, urlparse(url).path)\n\n@asynccontextmanager\ndef sse_client(url: str, headers: dict[str, Any] | None = None, timeout: float = 5, sse_read_timeout: float = 60 * 5):\n    '''\n    Client transport for SSE.\n\n    Args:\n        url (str): The URL to connect to for SSE.\n        headers (dict[str, Any] | None): Optional headers to include in the request.\n        timeout (float): The timeout for HTTP requests.\n        sse_read_timeout (float): The timeout for reading SSE events.\n    '''\n    read_stream: MemoryObjectReceiveStream[JSONRPCMessage | Exception]\n    read_stream_writer: MemoryObjectSendStream[JSONRPCMessage | Exception]\n\n    write_stream: MemoryObjectSendStream[JSONRPCMessage]\n    write_stream_reader: MemoryObjectReceiveStream[JSONRPCMessage]\n\n    read_stream_writer, read_stream = anyio.create_memory_object_stream(0)\n    write_stream, write_stream_reader = anyio.create_memory_object_stream(0)\n\n    async with anyio.create_task_group() as tg:\n        try:\n            logger.info(f"Connecting to SSE endpoint: {remove_request_params(url)}")\n            async with httpx.AsyncClient(headers=headers) as client:\n                async with aconnect_sse(\n                    client,\n                    "GET",\n                    url,\n                    timeout=httpx.Timeout(timeout, read=sse_read_timeout),\n                ) as event_source:\n                    event_source.response.raise_for_status()\n                    logger.debug("SSE connection established")\n\n                    async def sse_reader(task_status: TaskStatus[str] = anyio.TASK_STATUS_IGNORED):\n                        try:\n                            async for sse in event_source.aiter_sse():\n                                logger.debug(f"Received SSE event: {sse.event}")\n                                match sse.event:\n                                    case "endpoint":\n                                        endpoint_url = urljoin(url, sse.data)\n                                        logger.info(f"Received endpoint URL: {endpoint_url}")\n\n                                        url_parsed = urlparse(url)\n                                        endpoint_parsed = urlparse(endpoint_url)\n                                        if (url_parsed.netloc != endpoint_parsed.netloc or url_parsed.scheme != endpoint_parsed.scheme):\n                                            error_msg = f"Endpoint origin does not match connection origin: {endpoint_url}"\n                                            logger.error(error_msg)\n                                            raise ValueError(error_msg)\n\n                                        task_status.started(endpoint_url)\n\n                                    case "message":\n                                        try:\n                                            message = JSONRPCMessage.model_validate_json(sse.data)\n                                            logger.debug(f"Received server message: {message}")\n                                        except Exception as exc:\n                                            logger.error(f"Error parsing server message: {exc}")\n                                            await read_stream_writer.send(exc)\n                                            continue\n\n                                        await read_stream_writer.send(message)\n                        except Exception as exc:\n                            logger.error(f"Error in sse_reader: {exc}")\n                            await read_stream_writer.send(exc)\n                        finally:\n                            await read_stream_writer.aclose()\n\n                    async def post_writer(endpoint_url: str):\n                        try:\n                            async with write_stream_reader:\n                                async for message in write_stream_reader:\n                                    logger.debug(f"Sending client message: {message}")\n                                    response = await client.post(\n                                        endpoint_url,\n                                        json=message.model_dump(by_alias=True, exclude_none=True, mode="json"),\n                                    )\n                                    response.raise_for_status()\n                                    logger.debug(f"Client message sent successfully: {response.status_code}")\n                        except Exception as exc:\n                            logger.error(f"Error in post_writer: {exc}")\n                        finally:\n                            await write_stream.aclose()\n\n                    endpoint_url = await tg.start(sse_reader)\n                    logger.info(f"Starting post writer with endpoint URL: {endpoint_url}")\n                    tg.start_soon(post_writer, endpoint_url)\n\n                    try:\n                        yield read_stream, write_stream\n                    finally:\n                        tg.cancel_scope.cancel()\n        finally:\n            await read_stream_writer.aclose()\n            await write_stream.aclose()\n